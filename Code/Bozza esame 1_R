# I dati sono stati ricavati dal seguente sito web: https://earthengine.google.com/ 
https://code.earthengine.google.com/


# Pacchetti usati:
library(terra) #pacchetto per l'utilizzo della funzione rast()
library(imageRy) #pacchetto per l'utilizzo della funzione im.plotRGB()
library(viridis) #pacchetto che permette di creare plot di immagini con differenti palette di colori di viridis
library(ggridges) #pacchetto che permette di creare i plot ridgeline

# Questo codice ha come scopo quello di visualizzare e quantificare la variazione della copertura forestale della Pineta di Cervia - Milano Marittima (RA) prima e dopo il passaggio di una tromba d'aria, avvenuta il 10 luglio 2019, che ha portato ad una perdita di oltre 2500 piante.

# Codice utilizzato in java script su Google Earth Engine per ottenere le immagini della Pineta di Cervia - Milano Marittima (RA) prima e dopo il passaggio della tromba d'aria.
#in mark down rendere visibile il java script scrivendo: ``` JavaScript

 
#La prima immagine chiamata "pinetapre" riporta una collection di immagini che vanno dal 2018-06-01 al 2019-06-30, selezionando solo immagini con una copertura nuvolosa <20%.

// ==============================================
// Sentinel-2 Surface Reflectance - Cloud Masking and Visualization
// https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED
// ==============================================

// ==============================================
// Function to mask clouds using the QA60 band
// Bits 10 and 11 correspond to opaque clouds and cirrus
// ==============================================
function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Keep only pixels where both cloud and cirrus bits are 0
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
               .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  // Apply the cloud mask and scale reflectance values (0–10000 ➝ 0–1)
  return image.updateMask(mask).divide(10000);
}

// ==============================================
// Load and Prepare the Image Collection
// ==============================================

// Load Sentinel-2 SR Harmonized collection (atmospherical correction already done)
var collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                   .filterBounds(pinetapre)
                   .filterDate('2018-06-01', '2019-06-30')              // Filter by date                                  
                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20)) // Only images with <20% cloud cover
                   .map(maskS2clouds);                                  // Apply cloud masking

// Print number of images available after filtering
print('Number of images in collection:', collection.size());

// ==============================================
// Create a median composite from the collection
// Useful when the pinetapre overlaps multiple scenes or frequent cloud cover
// ==============================================
var composite = collection.median().clip(pinetapre);

// ==============================================
// Visualization on the Map
// ==============================================

Map.centerObject(pinetapre, 10); // Zoom to the pinetapre

// Display the first image of the collection (GEE does this by default)
Map.addLayer(collection, {
  bands: ['B4', 'B3', 'B2'],  // True color: Red, Green, Blue
  min: 0,
  max: 0.3
}, 'First image of collection');

// Display the median composite image
Map.addLayer(composite, {
  bands: ['B4', 'B3', 'B2'],
  min: 0,
  max: 0.3
}, 'Median composite');

// ==============================================
// Export to Google Drive
// ==============================================

// Export the median composite
Export.image.toDrive({
  image: composite.select(['B4', 'B3', 'B2']),  // Select RGB bands
  description: 'Pinetapre',
  folder: 'GEE_exports',                        // Folder in Google Drive
  fileNamePrefix: 'pinetapre',
  region: pinetapre ,
  scale: 10,                                    // Sentinel-2 resolution
  crs: 'EPSG:4326',
  maxPixels: 1e13
});


#La seconda immagine chiamata "pinetapost" riporta una collection di immagini che vanno dal 2019-07-10 al 2020-05-30, selezionando solo immagini con una copertura nuvolosa <20%.

// ==============================================
// Sentinel-2 Surface Reflectance - Cloud Masking and Visualization
// https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED
// ==============================================

// ==============================================
// Function to mask clouds using the QA60 band
// Bits 10 and 11 correspond to opaque clouds and cirrus
// ==============================================
function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Keep only pixels where both cloud and cirrus bits are 0
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
               .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  // Apply the cloud mask and scale reflectance values (0–10000 ➝ 0–1)
  return image.updateMask(mask).divide(10000);
}

// ==============================================
// Load and Prepare the Image Collection
// ==============================================

// Load Sentinel-2 SR Harmonized collection (atmospherical correction already done)
var collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                   .filterBounds(pinetapost)
                   .filterDate('2019-07-10', '2020-05-30')              // Filter by date                                
                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20)) // Only images with <20% cloud cover
                   .map(maskS2clouds);                                  // Apply cloud masking

// Print number of images available after filtering
print('Number of images in collection:', collection.size());

// ==============================================
// Create a median composite from the collection
// Useful when the pinetapost overlaps multiple scenes or frequent cloud cover
// ==============================================
var composite = collection.median().clip(pinetapost);

// ==============================================
// Visualization on the Map
// ==============================================

Map.centerObject(pinetapost, 10); // Zoom to the pinetapost

// Display the first image of the collection (GEE does this by default)
Map.addLayer(collection, {
  bands: ['B4', 'B3', 'B2'],  // True color: Red, Green, Blue
  min: 0,
  max: 0.3
}, 'First image of collection');

// Display the median composite image
Map.addLayer(composite, {
  bands: ['B4', 'B3', 'B2'],
  min: 0,
  max: 0.3
}, 'Median composite');

// ==============================================
// Export to Google Drive
// ==============================================

// Export the median composite
Export.image.toDrive({
  image: composite.select(['B4', 'B3', 'B2']),  // Select RGB bands
  description: 'Pinetapost',
  folder: 'GEE_exports',                        // Folder in Google Drive
  fileNamePrefix: 'pinetapost',
  region: pinetapost ,
  scale: 10,                                    // Sentinel-2 resolution
  crs: 'EPSG:4326',
  maxPixels: 1e13
});


#VISUALIZZAZIONE DEI DATI SATELLITARI:

# Una volta ottenute le due immagini su Drive, posso impostare la working directory per importarle e visualizzarle su R:

setwd("C://Users/gdemo/Desktop/Telerilevamento geoecologico/") #working directory in cui ho salvato il file da importare
pinetapre= rast("pinetapre.tif") #importo il raster
plot(pinetapre) #plot che mi permette di visualizzare l'immagine
plotRGB(pinetapre, r = 1, g = 2, b = 3, stretch = "lin", main = "pinetapre") #plot RGB per visualizzare l'immagine nello spettro del visibile
dev.off() #funzione con cui cancello l'ultima immagine visualizzata


# Ripeto le stesse funzioni anche per la seconda immagine:

setwd("C://Users/gdemo/Desktop/Telerilevamento geoecologico/") 
pinetapost= rast("pinetapost.tif")
plot(pinetapost) #plot che mi permette di visualizzare l'immagine
plotRGB(pinetapost, r = 1, g = 2, b = 3, stretch = "lin", main = "pinetapost") 
dev.off() 


# Creo un pannello multiframe per vedere le immagini a confronto:

im.multiframe(1,2) #funzione che apre un pannello multiframe che mi permette di vedere le  immagini una affianco all'altra
plotRGB(pinetapre, r = 1, g = 2, b = 3, stretch = "lin", main = "pinetapre")
plotRGB(pinetapost, r = 1, g = 2, b = 3, stretch = "lin", main = "pinetapost")
dev.off() #funzione con cui cancello l'ultima immagine visualizzata

im.multiframe(2,3) 
plot(pinetapre, col=magma(100)) #scelgo un colore dalla palette dei colori di viridis, dal pacchetto viridis, chiamato "magma" e il numero dei colori delle sfumature all’interno
plot(pinetapost, col=magma(100))
dedv.off()



# Scarico le immagini "pinetapreNIR" e "pinetapostNIR" aggiungendo una quarta banda, la B8 relativa al NIR:

# Script per ottenere l'immagine "pinetapreNIR":

// ==============================================
// Sentinel-2 Surface Reflectance - Cloud Masking and Visualization
// https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED
// ==============================================

// ==============================================
// Function to mask clouds using the QA60 band
// Bits 10 and 11 correspond to opaque clouds and cirrus
// ==============================================
function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Keep only pixels where both cloud and cirrus bits are 0
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
               .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  // Apply the cloud mask and scale reflectance values (0–10000 ➝ 0–1)
  return image.updateMask(mask).divide(10000);
}

// ==============================================
// Load and Prepare the Image Collection
// ==============================================

// Load Sentinel-2 SR Harmonized collection (atmospherical correction already done)
var collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                   .filterBounds(pinetapreNIR)
                   .filterDate('2018-06-01', '2019-06-30')              // Filter by date                                 
                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20)) // Only images with <20% cloud cover
                   .map(maskS2clouds);                                  // Apply cloud masking

// Print number of images available after filtering
print('Number of images in collection:', collection.size());

// ==============================================
// Create a median composite from the collection
// Useful when the pinetapreNIR overlaps multiple scenes or frequent cloud cover
// ==============================================
var composite = collection.median().clip(pinetapreNIR);

// ==============================================
// Visualization on the Map
// ==============================================

Map.centerObject(pinetapreNIR, 10); // Zoom to the pinetapreNIR

// Display the first image of the collection (GEE does this by default)
Map.addLayer(collection, {
  band: ['B4', 'B3', 'B2', 'B8'],  // NIR color
  min: 0,
  max: 0.3
}, 'First image of collection');

// Display the median composite image
Map.addLayer(composite, {
  band: ['B4', 'B3', 'B2', 'B8'], 
  min: 0,
  max: 0.3
}, 'Median composite');

// ==============================================
// Export to Google Drive
// ==============================================

// Export the median composite
Export.image.toDrive({
  image: composite.select(['B4', 'B3', 'B2', 'B8']),  // Select NIR band
  description: 'PinetapreNIR',
  folder: 'GEE_exports',                        // Folder in Google Drive
  fileNamePrefix: 'pinetapreNIR',
  region: pinetapreNIR,
  scale: 10,                                    // Sentinel-2 resolution
  crs: 'EPSG:4326',
  maxPixels: 1e13
});




# Script per ottenere l'immagine "pinetapostNIR":

// ==============================================
// Sentinel-2 Surface Reflectance - Cloud Masking and Visualization
// https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED
// ==============================================

// ==============================================
// Function to mask clouds using the QA60 band
// Bits 10 and 11 correspond to opaque clouds and cirrus
// ==============================================
function maskS2clouds(image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Keep only pixels where both cloud and cirrus bits are 0
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
               .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  // Apply the cloud mask and scale reflectance values (0–10000 ➝ 0–1)
  return image.updateMask(mask).divide(10000);
}

// ==============================================
// Load and Prepare the Image Collection
// ==============================================

// Load Sentinel-2 SR Harmonized collection (atmospherical correction already done)
var collection = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                   .filterBounds(pinetapostNIR)
                   .filterDate('2019-07-10', '2020-05-30')              // Filter by date                                 
                   .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20)) // Only images with <20% cloud cover
                   .map(maskS2clouds);                                  // Apply cloud masking

// Print number of images available after filtering
print('Number of images in collection:', collection.size());

// ==============================================
// Create a median composite from the collection
// Useful when the pinetapostNIR overlaps multiple scenes or frequent cloud cover
// ==============================================
var composite = collection.median().clip(pinetapostNIR);

// ==============================================
// Visualization on the Map
// ==============================================

Map.centerObject(pinetapostNIR, 10); // Zoom to the pinetapostNIR

// Display the first image of the collection (GEE does this by default)
Map.addLayer(collection, {
  band: ['B4', 'B3', 'B2', 'B8'],  // NIR color
  min: 0,
  max: 0.3
}, 'First image of collection');

// Display the median composite image
Map.addLayer(composite, {
  band: ['B4', 'B3', 'B2', 'B8'], 
  min: 0,
  max: 0.3
}, 'Median composite');

// ==============================================
// Export to Google Drive
// ==============================================

// Export the median composite
Export.image.toDrive({
  image: composite.select(['B4', 'B3', 'B2', 'B8']),  // Select NIR band
  description: 'PinetapostNIR',
  folder: 'GEE_exports',                        // Folder in Google Drive
  fileNamePrefix: 'pinetapostNIR',
  region: pinetapostNIR,
  scale: 10,                                    // Sentinel-2 resolution
  crs: 'EPSG:4326',
  maxPixels: 1e13
});


# Una volta ottenute le due immagini su Drive, posso impostare la working directory per importarle e visualizzarle su R:
# Ripeto le stesse funzioni viste in precedenza:

setwd("C://Users/gdemo/Desktop/Telerilevamento geoecologico/") 
pinetapreNIR= rast("pinetapreNIR.tif")
plot(pinetapreNIR)
plot(pinetapreNIR, col=magma(100))
dev.off()

setwd("C://Users/gdemo/Desktop/Telerilevamento geoecologico/")
pinetapostNIR= rast("pinetapostNIR.tif")
plot(pinetapostNIR)
plot(pinetapostNIR, col=magma(100))
dev.off()

im.multiframe(1,2) #isolo e visualizzo solo le bande 8 relative al NIR delle due immagini una accanto all'altra
plot(pinetapreNIR[[4]], stretch="lin", main = "pinetapreNIR", col=magma(100))
plot(pinetapostNIR[[4]], stretch="lin", main = "pinetapostNIR", col=magma(100))
dev.off()

im.multiframe(1,2)
plotRGB(pinetapreNIR, r = 1, g = 2, b = 4, stretch="lin", main = "pinetapreNIR") #ho montato sulla componente blue (b) dello schema RGB la banda dell’infrarosso corrispondente a 4. Quindi vedrò le piante di colore blu, mentre appare nella scala del giallo tutto quello che non è vegetazione (questa funzione con il blu si usa di solito per evidenziare aree con suolo nudo).
plotRGB(pinetapostNIR, r = 1, g = 2, b = 4, stretch="lin", main = "pinetapostNIR")
dev.off()



#CALCOLO DEGLI INDICI SPETTRALI

# Calcolo il DVI: Difference Vegetation Index che ci dà informazione sullo stato delle piante, basandosi sulla banda B8 relativa al NIR. Se l’albero è stressato, le cellule a palizzata collassano, allora la riflettanza nel NIR sarà più bassa.

#Ricordiamo le bande:
#4 = NIR
#1 =red

DVIpre = pinetapreNIR[[4]] - pinetapreNIR[[1]] #NIR - red
plot(DVIpre)
plot(DVIpre, col=inferno(100))
dev.off()

DVIpost = pinetapostNIR[[4]] - pinetapostNIR[[1]] #NIR - red
plot(DVIpost)
plot(DVIpost, col=inferno(100))
dev.off()

im.multiframe(1,2)
plot(DVIpre, stretch = "lin", main = "DVIpre", col=inferno(100))
plot(DVIpost, stretch = "lin", main = "DVIpost", col=inferno(100))
dev.off()
# Nella prima immagine si vede un maggior valore della biomassa (colori tendenti al giallo), rispetto alla seconda dove sono chiaramente visibili i danni causati dal passaggio della tromba d'aria al centro della pineta.


????
dvipreauto = im.dvi(pinetapre, 1, 2)
plot(dvipreauto)
dev.off()

dvipostauto = im.dvi(pinetapost, 1, 2)
plot(dvipostauto)
dev.off()

im.multiframe(1,2)
plot(dvipreauto)
plot(dvipostauto)

im.multiframe(2,2)
plot(dvipreauto, col=inferno(100))
plot(dvipostauto, col=inferno(100))
plot(DVIpre, stretch = "lin", main = "DVIpre", col=inferno(100))
plot(DVIpost, stretch = "lin", main = "DVIpost", col=inferno(100))

????


#ANALISI MULTITEMPORALE

# Possiamo usare R per effettuare un'analisi multi temporale: vedere come cambia un'area nel tempo

# Sottraiamo l’immagine della pineta post tromba d'aria da quella pre tromba d'aria per vedere le differenze:
pinetadif = pinetapre[[1]] - pinetapost[[1]] # abbiamo estratto il livello 1 da entrambe le immagini
plot(pinetadif, stretch = "lin", main = "Pinetadif", col=inferno(100)) 
# Tutto ciò che ha un colore più scuro ha un valore maggiore, in questo modo è ben visibile la traccia lasciata dal passaggio del tornado 


# Possaimo utilizzare la funzione Plot Ridgeline: funzione che prende tutti i pixel di ogni periodo e calcola la frequenza dei pixel per poi creare grafici che mostrano la distribuzione delle frequenze di ogni singolo momento e le distribuiscono in una serie temporale.
#per fare l'analisis multitemporale occorre confrontare 
im.ridgeline(pinetapreNIR, scale=2, palette="mako")) # Imposto scale=2 con cui vado ad indicare l’altezza del grafico che si va a sovrapporre al grafico successivo creando un effetto 3D e imposto un colore.
im.ridgeline(pinetapostNIR, scale=2, palette="mako"))




#Conclusioni:
#Ci vorrebbero analisi a più alta risoluzione per rendere visibile ogni singolo albero.

